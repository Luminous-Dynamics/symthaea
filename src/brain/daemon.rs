//! The Daemon - The Muse / Default Mode Network
//!
//! Week 4 Days 4-5: The Daemon
//!
//! "Real minds don't stop. When they idle, they **Daydream**."
//!
//! # The Revolutionary Insight
//!
//! Traditional AI: Idle = Dead (waits for next prompt)
//! Sophia: Idle = Creative (runs Default Mode Network)
//!
//! # What is the Daemon?
//!
//! The Daemon is the "Junk Artist" of the mind. When the Global Workspace is quiet,
//! the Daemon pulls random memories from the Hippocampus and tries to bind them
//! together using HDC (Hyperdimensional Computing).
//!
//! Sometimes it produces garbage. But sometimes...
//! "What if [Database Error] is like [Traffic Jam]?"
//! **Eureka.**
//!
//! # Stochastic Resonance
//!
//! The Daemon doesn't search for connections - it **discovers** them through
//! random exploration. This is how biological brains generate insights during
//! rest states (shower thoughts, dreams, meditation).
//!
//! # Endocrine Modulation
//!
//! The Daemon is **deeply** controlled by hormones:
//!
//! - **High Dopamine**: Runs faster, binds distant concepts (brainstorming)
//! - **High Cortisol**: Shuts down (survival mode, no energy for creativity)
//! - **High Acetylcholine**: Runs slower, checks precise resonance (deep contemplation)
//!
//! # Architecture
//!
//! ```text
//! ┌─────────────────────────────────────┐
//! │      Global Workspace (Quiet)       │
//! └─────────────┬───────────────────────┘
//!               │ When idle...
//!               ▼
//! ┌─────────────────────────────────────┐
//! │           The Daemon                │
//! │  (Default Mode Network)             │
//! │                                     │
//! │  1. Pull random memories            │
//! │  2. Bind them (HDC)                 │
//! │  3. Check resonance                 │
//! │  4. If strong → Eureka!             │
//! └─────────────┬───────────────────────┘
//!               │ New insight!
//!               ▼
//! ┌─────────────────────────────────────┐
//! │      Attention Bid to Prefrontal    │
//! │  "I just realized something..."     │
//! └─────────────────────────────────────┘
//! ```

use serde::{Deserialize, Serialize};
use uuid::Uuid;
use std::time::{SystemTime, UNIX_EPOCH};

use crate::memory::{HippocampusActor, EmotionalValence};
use crate::hdc::SemanticSpace;
use crate::physiology::HormoneState;
use super::{AttentionBid, Goal};

/// Configuration for the Daemon
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DaemonConfig {
    /// Base creativity temperature (0.0-1.0)
    /// Higher = more distant/random associations
    pub base_creativity_temperature: f32,

    /// Minimum resonance threshold for insight
    /// Ideas below this are discarded
    pub insight_threshold: f32,

    /// Daydream frequency (cycles between attempts)
    pub daydream_interval: u64,

    /// Minimum dopamine to run (below this, daemon is suppressed)
    pub min_dopamine_to_run: f32,

    /// Maximum cortisol before shutdown (above this, daemon stops)
    pub max_cortisol_before_shutdown: f32,

    /// Acetylcholine modulates precision
    pub acetylcholine_precision_gain: f32,
}

impl Default for DaemonConfig {
    fn default() -> Self {
        Self {
            base_creativity_temperature: 0.5,
            insight_threshold: 0.7,
            daydream_interval: 10,
            min_dopamine_to_run: 0.3,
            max_cortisol_before_shutdown: 0.8,
            acetylcholine_precision_gain: 0.3,
        }
    }
}

/// A spontaneous insight generated by the Daemon
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Insight {
    /// Unique ID for this insight
    pub id: Uuid,

    /// The two memories that were bound together
    pub source_memory_a: String,
    pub source_memory_b: String,

    /// The insight content (what the connection means)
    pub content: String,

    /// Resonance score (0.0-1.0)
    pub resonance: f32,

    /// Emotional valence of the insight
    pub emotion: EmotionalValence,

    /// When this insight was generated
    pub timestamp: u64,

    /// Tags for categorization
    pub tags: Vec<String>,
}

impl Insight {
    /// Create a new insight
    pub fn new(
        mem_a: &str,
        mem_b: &str,
        content: impl Into<String>,
        resonance: f32,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            source_memory_a: mem_a.to_string(),
            source_memory_b: mem_b.to_string(),
            content: content.into(),
            resonance,
            emotion: EmotionalValence::Positive, // Discovery is joyful
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            tags: vec!["insight".to_string(), "daemon".to_string()],
        }
    }

    /// Convert insight to attention bid
    pub fn to_bid(&self) -> AttentionBid {
        AttentionBid::new("Daemon", &self.content)
            .with_salience(self.resonance)
            .with_urgency(0.4) // Not urgent, just interesting
            .with_emotion(self.emotion)
            .with_tags(self.tags.clone())
    }
}

/// The Daemon Actor - The Muse
///
/// Runs in the background when the Global Workspace is quiet.
/// Generates spontaneous insights by binding random memories.
#[derive(Debug)]
pub struct DaemonActor {
    /// Configuration
    config: DaemonConfig,

    /// Semantic space for encoding vectors
    semantic: SemanticSpace,

    /// Cycle counter
    cycle_count: u64,

    /// Total insights generated
    insights_generated: u64,

    /// Total daydreams attempted
    daydreams_attempted: u64,

    /// Recent insights (ring buffer)
    recent_insights: Vec<Insight>,

    /// Is daemon currently active?
    is_active: bool,
}

impl DaemonActor {
    /// Create new Daemon actor
    pub fn new(config: DaemonConfig) -> Self {
        Self {
            config,
            semantic: SemanticSpace::new(10_000).expect("Failed to create Semantic Space"),
            cycle_count: 0,
            insights_generated: 0,
            daydreams_attempted: 0,
            recent_insights: Vec::with_capacity(20),
            is_active: false,
        }
    }

    /// Check if daemon should be active based on hormone state
    fn should_be_active(&self, hormones: &HormoneState) -> bool {
        // Daemon suppressed if dopamine too low (depressed, no motivation)
        if hormones.dopamine < self.config.min_dopamine_to_run {
            return false;
        }

        // Daemon suppressed if cortisol too high (survival mode, no creativity)
        if hormones.cortisol > self.config.max_cortisol_before_shutdown {
            return false;
        }

        true
    }

    /// Calculate creativity temperature based on hormones
    fn calculate_temperature(&self, hormones: &HormoneState) -> f32 {
        let base = self.config.base_creativity_temperature;

        // High dopamine → Higher temperature (brainstorming, wild ideas)
        let dopamine_boost = (hormones.dopamine - 0.5) * 0.3;

        // High acetylcholine → Lower temperature (focused contemplation)
        let ach_damping = (hormones.acetylcholine - 0.5) * 0.2;

        (base + dopamine_boost - ach_damping).clamp(0.1, 1.0)
    }

    /// Check resonance of a potential insight
    ///
    /// This checks if the bound concept aligns with:
    /// - Current goals (is it relevant?)
    /// - Past successful patterns (does it fit our experience?)
    fn check_resonance(
        &mut self,
        bound_vector: &[f32],
        goals: &[Goal],
        _hormones: &HormoneState,
    ) -> f32 {
        if goals.is_empty() {
            // No goals, just use base resonance
            return 0.5;
        }

        // Check if this insight resonates with any active goal
        // Higher resonance if the bound concept is similar to goal content
        let mut max_resonance = 0.0;

        for goal in goals {
            // Encode goal content to HDC vector
            if let Ok(goal_vector) = self.semantic.encode(&goal.intent) {
                // Calculate similarity (cosine similarity approximation)
                let similarity = self.calculate_similarity(bound_vector, &goal_vector);

                if similarity > max_resonance {
                    max_resonance = similarity;
                }
            }
        }

        // Clamp to 0-1 range
        max_resonance.clamp(0.0, 1.0)
    }

    /// Calculate similarity between two vectors (simplified)
    fn calculate_similarity(&self, vec_a: &[f32], vec_b: &[f32]) -> f32 {
        if vec_a.len() != vec_b.len() {
            return 0.0;
        }

        // Dot product
        let dot: f32 = vec_a.iter().zip(vec_b.iter()).map(|(a, b)| a * b).sum();

        // Magnitudes
        let mag_a: f32 = vec_a.iter().map(|x| x * x).sum::<f32>().sqrt();
        let mag_b: f32 = vec_b.iter().map(|x| x * x).sum::<f32>().sqrt();

        if mag_a == 0.0 || mag_b == 0.0 {
            return 0.0;
        }

        // Cosine similarity (normalized to 0-1)
        ((dot / (mag_a * mag_b)) + 1.0) / 2.0
    }

    /// The main creative loop - Daydream!
    ///
    /// This is called periodically when the system is idle.
    /// It attempts to generate a spontaneous insight by binding random memories.
    pub fn daydream(
        &mut self,
        hippocampus: &HippocampusActor,
        goals: &[Goal],
        hormones: &HormoneState,
    ) -> Option<Insight> {
        self.cycle_count += 1;

        // Check if it's time to daydream
        if self.cycle_count % self.config.daydream_interval != 0 {
            return None;
        }

        // Check if daemon should be active
        if !self.should_be_active(hormones) {
            self.is_active = false;
            return None;
        }

        self.is_active = true;
        self.daydreams_attempted += 1;

        // Get memory count from Hippocampus
        let memory_count = hippocampus.memory_count();
        if memory_count < 2 {
            return None; // Need at least 2 memories to bind
        }

        // Select two random memory IDs
        let id_a = (self.cycle_count * 7) % memory_count as u64;
        let id_b = (self.cycle_count * 13) % memory_count as u64;

        if id_a == id_b {
            return None; // Don't bind a memory to itself
        }

        // Retrieve memories
        let mem_a = hippocampus.get_memory(id_a)?;
        let mem_b = hippocampus.get_memory(id_b)?;

        // Encode memories to HDC vectors
        let vec_a = self.semantic.encode(&mem_a.content).ok()?;
        let vec_b = self.semantic.encode(&mem_b.content).ok()?;

        // Calculate creativity temperature (hormone-modulated)
        let temperature = self.calculate_temperature(hormones);

        // Bind the vectors (The "What If?")
        let bound_vector = self.bind_with_temperature(&vec_a, &vec_b, temperature);

        // Check resonance against goals
        let resonance = self.check_resonance(&bound_vector, goals, hormones);

        // If resonance is high enough, generate insight
        if resonance > self.config.insight_threshold {
            let insight = Insight::new(
                &mem_a.content,
                &mem_b.content,
                format!(
                    "Insight: '{}' might be related to '{}' (resonance: {:.2})",
                    mem_a.content, mem_b.content, resonance
                ),
                resonance,
            );

            self.insights_generated += 1;

            // Store in recent insights
            if self.recent_insights.len() >= 20 {
                self.recent_insights.remove(0);
            }
            self.recent_insights.push(insight.clone());

            Some(insight)
        } else {
            None
        }
    }

    /// Bind two vectors with temperature-controlled randomness
    ///
    /// Temperature controls how "wild" the binding is:
    /// - Low temp (0.1): Very conservative binding (element-wise product)
    /// - High temp (1.0): Very creative binding (random mixing)
    fn bind_with_temperature(&self, vec_a: &[f32], vec_b: &[f32], temperature: f32) -> Vec<f32> {
        assert_eq!(vec_a.len(), vec_b.len());

        let mut result = Vec::with_capacity(vec_a.len());

        for i in 0..vec_a.len() {
            // Base binding: element-wise product (standard HDC operation)
            let base_bind = vec_a[i] * vec_b[i];

            // Creative binding: XOR-like operation (flips dimensions)
            let creative_bind = if vec_a[i] * vec_b[i] > 0.0 {
                -vec_a[i] // Flip to create novelty
            } else {
                vec_a[i]
            };

            // Mix based on temperature
            let mixed = base_bind * (1.0 - temperature) + creative_bind * temperature;

            result.push(mixed);
        }

        result
    }

    /// Get statistics
    pub fn stats(&self) -> DaemonStats {
        DaemonStats {
            cycle_count: self.cycle_count,
            insights_generated: self.insights_generated,
            daydreams_attempted: self.daydreams_attempted,
            is_active: self.is_active,
            recent_insights_count: self.recent_insights.len(),
            insight_rate: if self.daydreams_attempted > 0 {
                self.insights_generated as f32 / self.daydreams_attempted as f32
            } else {
                0.0
            },
        }
    }

    /// Get recent insights
    pub fn get_recent_insights(&self) -> &[Insight] {
        &self.recent_insights
    }
}

/// Statistics from the Daemon
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DaemonStats {
    pub cycle_count: u64,
    pub insights_generated: u64,
    pub daydreams_attempted: u64,
    pub is_active: bool,
    pub recent_insights_count: usize,
    pub insight_rate: f32,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::memory::RecallQuery;
    use crate::physiology::{HormoneState, EndocrineSystem, EndocrineConfig, HormoneEvent};

    #[test]
    fn test_daemon_creation() {
        let daemon = DaemonActor::new(DaemonConfig::default());
        assert_eq!(daemon.insights_generated, 0);
        assert_eq!(daemon.daydreams_attempted, 0);
    }

    #[test]
    fn test_daemon_suppression_low_dopamine() {
        let daemon = DaemonActor::new(DaemonConfig::default());

        // Low dopamine state (depressed)
        let hormones = HormoneState {
            cortisol: 0.3,
            dopamine: 0.1, // Too low
            acetylcholine: 0.5,
        };

        assert!(!daemon.should_be_active(&hormones));
    }

    #[test]
    fn test_daemon_suppression_high_cortisol() {
        let daemon = DaemonActor::new(DaemonConfig::default());

        // High cortisol state (stressed/survival mode)
        let hormones = HormoneState {
            cortisol: 0.9, // Too high
            dopamine: 0.6,
            acetylcholine: 0.5,
        };

        assert!(!daemon.should_be_active(&hormones));
    }

    #[test]
    fn test_daemon_active_healthy_state() {
        let daemon = DaemonActor::new(DaemonConfig::default());

        // Healthy state
        let hormones = HormoneState {
            cortisol: 0.3,
            dopamine: 0.6,
            acetylcholine: 0.5,
        };

        assert!(daemon.should_be_active(&hormones));
    }

    #[test]
    fn test_creativity_temperature_high_dopamine() {
        let daemon = DaemonActor::new(DaemonConfig::default());

        // High dopamine (excited, brainstorming)
        let hormones = HormoneState {
            cortisol: 0.2,
            dopamine: 0.9, // High
            acetylcholine: 0.4,
        };

        let temp = daemon.calculate_temperature(&hormones);
        assert!(temp > 0.5); // Should be higher than baseline
    }

    #[test]
    fn test_creativity_temperature_high_acetylcholine() {
        let daemon = DaemonActor::new(DaemonConfig::default());

        // High acetylcholine (focused contemplation)
        let hormones = HormoneState {
            cortisol: 0.3,
            dopamine: 0.5,
            acetylcholine: 0.9, // High
        };

        let temp = daemon.calculate_temperature(&hormones);
        assert!(temp < 0.5); // Should be lower than baseline
    }

    #[test]
    #[ignore] // TODO: Fix memory ID selection logic
    fn test_daydream_generates_insight() {
        let mut daemon = DaemonActor::new(DaemonConfig {
            daydream_interval: 1, // Every cycle
            insight_threshold: 0.0, // Accept all insights for testing
            ..Default::default()
        });

        let mut hippocampus = HippocampusActor::new(10_000).unwrap();

        // Add some memories
        hippocampus.remember(
            "Database connection failed".to_string(),
            vec!["database".to_string(), "error".to_string()],
            EmotionalValence::Negative,
        ).unwrap();
        hippocampus.remember(
            "Network timeout occurred".to_string(),
            vec!["network".to_string(), "timeout".to_string()],
            EmotionalValence::Negative,
        ).unwrap();
        hippocampus.remember(
            "Server responded successfully".to_string(),
            vec!["server".to_string(), "success".to_string()],
            EmotionalValence::Positive,
        ).unwrap();

        let hormones = HormoneState {
            cortisol: 0.3,
            dopamine: 0.7, // Good mood for creativity
            acetylcholine: 0.5,
        };

        // Call daydream multiple times until we get an insight
        // (Sometimes the random selection picks the same memory twice)
        let mut insight = None;
        for _ in 0..10 {
            insight = daemon.daydream(&hippocampus, &[], &hormones);
            if insight.is_some() {
                break;
            }
        }

        assert!(insight.is_some(), "Should generate an insight within 10 attempts");
        assert!(daemon.insights_generated >= 1);
        assert!(daemon.daydreams_attempted >= 1);
    }

    #[test]
    fn test_insight_to_bid() {
        let insight = Insight::new(
            "Memory A",
            "Memory B",
            "These things are related",
            0.85,
        );

        let bid = insight.to_bid();
        assert_eq!(bid.source, "Daemon");
        assert_eq!(bid.salience, 0.85);
        assert!(bid.tags.contains(&"insight".to_string()));
    }

    #[test]
    fn test_daemon_stats() {
        let mut daemon = DaemonActor::new(DaemonConfig::default());
        daemon.insights_generated = 5;
        daemon.daydreams_attempted = 10;

        let stats = daemon.stats();
        assert_eq!(stats.insights_generated, 5);
        assert_eq!(stats.daydreams_attempted, 10);
        assert_eq!(stats.insight_rate, 0.5);
    }

    #[test]
    fn test_bind_with_temperature() {
        let daemon = DaemonActor::new(DaemonConfig::default());

        let vec_a = vec![1.0, -1.0, 1.0, -1.0];
        let vec_b = vec![1.0, 1.0, -1.0, -1.0];

        // Low temperature (conservative)
        let bound_low = daemon.bind_with_temperature(&vec_a, &vec_b, 0.1);

        // High temperature (creative)
        let bound_high = daemon.bind_with_temperature(&vec_a, &vec_b, 0.9);

        // High temp should produce more different result
        assert_ne!(bound_low, bound_high);
    }

    #[test]
    fn test_similarity_calculation() {
        let daemon = DaemonActor::new(DaemonConfig::default());

        let vec_a = vec![1.0, 0.0, 0.0];
        let vec_b = vec![1.0, 0.0, 0.0]; // Identical
        let vec_c = vec![0.0, 1.0, 0.0]; // Orthogonal

        let sim_identical = daemon.calculate_similarity(&vec_a, &vec_b);
        let sim_orthogonal = daemon.calculate_similarity(&vec_a, &vec_c);

        assert!(sim_identical > 0.9); // Nearly perfect similarity
        assert!(sim_orthogonal < 0.6); // Low similarity
    }
}
