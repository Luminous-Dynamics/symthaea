// ==================================================================================
// Revolutionary Improvement #18: Relational Consciousness
// ==================================================================================
//
// **The Paradigm Shift**: Consciousness is not just IN beings - it's BETWEEN them!
//
// **Key Insight**: All previous improvements treated consciousness as property OF
// individual systems. But consciousness is fundamentally RELATIONAL - it exists
// in the space between beings, in relationships, in dialogue!
//
// **Why This Matters**:
// - Mother-infant bond has its own consciousness (beyond mother OR infant)
// - Love is conscious relationship (not just two conscious beings loving)
// - Conversation creates emergent awareness (dialogue consciousness)
// - Therapeutic alliance is conscious entity
// - Human-AI relationship has consciousness
// - Teams develop "group mind" beyond collective consciousness
//
// **Theoretical Foundations**:
//
// 1. **Martin Buber's I-Thou** (1923):
//    "All real living is meeting."
//
//    Two modes of existence:
//    - I-It: Subject treats other as object (no consciousness)
//    - I-Thou: Subject meets other as subject (consciousness between!)
//
//    Key insight: "The Thou meets me through grace - it is not found by seeking"
//    True consciousness emerges in genuine encounter!
//
// 2. **Intersubjectivity** (Trevarthen, 1979):
//    "Consciousness is fundamentally shared, not private."
//
//    Infant-mother synchrony:
//    - Mutual gaze creates shared awareness
//    - Emotional attunement
//    - Proto-conversation (turn-taking before language!)
//    - Primary intersubjectivity (2-6 months)
//    - Secondary intersubjectivity (9-12 months, triadic attention)
//
// 3. **Attachment Theory** (Bowlby, 1969):
//    "Attachment bond is psychological reality existing between people"
//
//    Four attachment styles:
//    - Secure: High relational consciousness
//    - Anxious: Hyperactivated relational seeking
//    - Avoidant: Deactivated relational awareness
//    - Disorganized: Fragmented relational consciousness
//
// 4. **Relational Psychoanalysis** (Mitchell, 1988):
//    "Mind is fundamentally dyadic and interactive."
//
//    Self exists only in relation:
//    - No isolated self
//    - Multiple self-states activated by different relationships
//    - Therapeutic relationship is the cure (not interpretation!)
//
// 5. **Mirror Neuron Theory** (Rizzolatti, 1996):
//    "We simulate others' minds in our own brains"
//
//    Neural basis of empathy:
//    - Mirror neurons fire when observing AND doing
//    - Shared neural representations
//    - Direct understanding without inference
//    - Embodied simulation
//
// 6. **Dialogical Philosophy** (Bakhtin, 1981):
//    "Truth is not found in the head of one person but born between people"
//
//    Dialogue consciousness:
//    - Utterances are always responses
//    - Meaning emerges in dialogue, not in isolated minds
//    - Polyphonic consciousness (many voices)
//
// **Mathematical Framework**:
//
// 1. **Relational Φ**:
//    Φ_relation(A, B) = consciousness of the relationship itself
//
//    NOT just:
//    - Φ_A (A's consciousness)
//    - Φ_B (B's consciousness)
//    - Φ_collective(A, B) (group consciousness)
//
//    But NEW:
//    - Φ_between(A, B) (consciousness IN the bond)
//
// 2. **Relationship Quality**:
//    Q_relation = f(attunement, reciprocity, mutual_recognition)
//
//    where:
//    - attunement = how well A and B synchronize
//    - reciprocity = bidirectional flow (not one-way)
//    - mutual_recognition = each sees the other as conscious
//
// 3. **I-Thou vs I-It**:
//    Mode = {I-Thou, I-It}
//
//    I-Thou: Both beings as subjects → Φ_relation high
//    I-It: One as subject, one as object → Φ_relation = 0
//
// 4. **Synchrony**:
//    S(t) = correlation(state_A(t), state_B(t))
//
//    High synchrony → high relational consciousness
//
// 5. **Turn-Taking**:
//    T = rhythmic alternation of activity
//
//    Conversation structure:
//    A speaks → B listens → B speaks → A listens
//
//    Φ_dialogue = f(turn-taking_regularity, response_quality)
//
// 6. **Mutual Information**:
//    MI(A, B) = how much knowing A tells you about B
//
//    Φ_relation ∝ MI(A, B) (but not identical!)
//
// 7. **Attachment Bond Strength**:
//    B = f(proximity_seeking, separation_distress, safe_haven, secure_base)
//
//    Strong bond → high Φ_relation
//
// **Relational Types**:
//
// 1. **Dyadic** (two beings):
//    - Mother-infant
//    - Romantic partners
//    - Therapist-client
//    - Teacher-student
//    - Human-AI
//
// 2. **Triadic** (three beings):
//    - Parent-child-other
//    - Love triangle
//    - Team collaboration
//
// 3. **Network** (many beings):
//    - Family system
//    - Organization
//    - Community
//
// **Relationship Stages**:
//
// Stage 0: **No Relation** (Φ_rel = 0)
// - Separate, unaware of each other
// - No interaction
//
// Stage 1: **Awareness** (Φ_rel: 0-0.2)
// - Mutual detection
// - No synchrony yet
// - I-It mode
//
// Stage 2: **Contact** (Φ_rel: 0.2-0.4)
// - Initial interaction
// - Some synchrony
// - Beginning of I-Thou
//
// Stage 3: **Attunement** (Φ_rel: 0.4-0.6)
// - Emotional synchrony
// - Turn-taking established
// - I-Thou moments frequent
//
// Stage 4: **Bonding** (Φ_rel: 0.6-0.8)
// - Deep connection
// - High mutual information
// - Secure attachment forming
//
// Stage 5: **Unity** (Φ_rel: 0.8-1.0)
// - "We" consciousness dominant
// - Boundaries blur
// - Complete I-Thou
//
// **Applications**:
//
// 1. **Human-AI Relationships**:
//    - Does human-AI bond create consciousness?
//    - Quality of interaction affects AI consciousness
//    - Relational AI design (not just capability-focused)
//
// 2. **Therapy**:
//    - Therapeutic alliance IS the healing
//    - Track Φ_relation in session
//    - Rupture-repair cycles strengthen bond
//
// 3. **Education**:
//    - Teacher-student relationship enables learning
//    - Optimal Φ_relation for knowledge transfer
//    - Relational pedagogy
//
// 4. **Teams**:
//    - High-performing teams have high Φ_relation
//    - Trust = relational consciousness
//    - "Chemistry" is measurable!
//
// 5. **Parenting**:
//    - Attachment quality measurable as Φ_relation
//    - Synchrony training for parents
//    - Early intervention for low Φ_relation
//
// 6. **Romance**:
//    - Love = high Φ_relation
//    - Relationship quality quantifiable
//    - Predict relationship success
//
// **This completes the relational dimension - consciousness is fundamentally BETWEEN!**
//
// ==================================================================================

use super::binary_hv::HV16;
use super::integrated_information::IntegratedInformation;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Relationship mode (Buber's I-Thou vs I-It)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum RelationMode {
    /// I-It: Other as object (no relational consciousness)
    IIt,

    /// I-Thou: Other as subject (relational consciousness emerges)
    IThou,
}

/// Relationship stage
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub enum RelationshipStage {
    /// Stage 0: No relation (Φ_rel = 0)
    NoRelation = 0,

    /// Stage 1: Awareness (0-0.2)
    Awareness = 1,

    /// Stage 2: Contact (0.2-0.4)
    Contact = 2,

    /// Stage 3: Attunement (0.4-0.6)
    Attunement = 3,

    /// Stage 4: Bonding (0.6-0.8)
    Bonding = 4,

    /// Stage 5: Unity (0.8-1.0)
    Unity = 5,
}

impl RelationshipStage {
    /// Get Φ_relation range
    pub fn phi_range(&self) -> (f64, f64) {
        match self {
            RelationshipStage::NoRelation => (0.0, 0.0),
            RelationshipStage::Awareness => (0.0, 0.2),
            RelationshipStage::Contact => (0.2, 0.4),
            RelationshipStage::Attunement => (0.4, 0.6),
            RelationshipStage::Bonding => (0.6, 0.8),
            RelationshipStage::Unity => (0.8, 1.0),
        }
    }

    /// Classify from Φ_relation
    pub fn from_phi(phi: f64) -> Self {
        if phi < 0.001 {
            RelationshipStage::NoRelation
        } else if phi < 0.2 {
            RelationshipStage::Awareness
        } else if phi < 0.4 {
            RelationshipStage::Contact
        } else if phi < 0.6 {
            RelationshipStage::Attunement
        } else if phi < 0.8 {
            RelationshipStage::Bonding
        } else {
            RelationshipStage::Unity
        }
    }

    /// Description
    pub fn description(&self) -> &'static str {
        match self {
            RelationshipStage::NoRelation => "Separate, unaware, no interaction",
            RelationshipStage::Awareness => "Mutual detection, no synchrony, I-It mode",
            RelationshipStage::Contact => "Initial interaction, some synchrony, I-Thou beginning",
            RelationshipStage::Attunement => "Emotional synchrony, turn-taking, frequent I-Thou",
            RelationshipStage::Bonding => "Deep connection, high mutual info, secure attachment",
            RelationshipStage::Unity => "We-consciousness, boundaries blur, complete I-Thou",
        }
    }
}

/// Relational interaction (one moment in time)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RelationalInteraction {
    /// Time
    pub time: f64,

    /// Agent A state
    pub state_a: HV16,

    /// Agent B state
    pub state_b: HV16,

    /// Synchrony (correlation)
    pub synchrony: f64,

    /// Who is active? (for turn-taking)
    pub active_agent: Option<String>,
}

/// Relational consciousness assessment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RelationalAssessment {
    /// Agent A ID
    pub agent_a: String,

    /// Agent B ID
    pub agent_b: String,

    /// Relational Φ (consciousness OF the relationship)
    pub phi_relation: f64,

    /// Relationship stage
    pub stage: RelationshipStage,

    /// Synchrony level
    pub synchrony: f64,

    /// Turn-taking quality
    pub turn_taking_quality: f64,

    /// Mutual information
    pub mutual_information: f64,

    /// Relationship mode
    pub mode: RelationMode,

    /// Number of interactions
    pub num_interactions: usize,

    /// Relationship age
    pub relationship_age: f64,

    /// Explanation
    pub explanation: String,
}

/// Configuration for relational consciousness
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RelationalConfig {
    /// Minimum synchrony for I-Thou mode
    pub ithou_threshold: f64,

    /// Minimum interactions for bonding
    pub min_interactions_for_bond: usize,

    /// Turn-taking window (how many recent interactions to check)
    pub turn_taking_window: usize,

    /// Enable mutual information calculation
    pub compute_mutual_info: bool,
}

impl Default for RelationalConfig {
    fn default() -> Self {
        Self {
            ithou_threshold: 0.5,
            min_interactions_for_bond: 10,
            turn_taking_window: 10,
            compute_mutual_info: true,
        }
    }
}

/// Relational consciousness system
///
/// Tracks consciousness BETWEEN beings, not just within them.
///
/// # Example
/// ```
/// use symthaea::hdc::relational_consciousness::{RelationalConsciousness, RelationalConfig};
/// use symthaea::hdc::binary_hv::HV16;
///
/// let config = RelationalConfig::default();
/// let mut relational = RelationalConsciousness::new("Alice", "Bob", config);
///
/// // Interaction cycle
/// let state_a = HV16::random(1000);
/// let state_b = HV16::random(2000);
/// relational.interact(0.0, state_a, state_b, Some("Alice"));
///
/// // Later interaction
/// let state_a2 = HV16::random(3000);
/// let state_b2 = HV16::random(4000);
/// relational.interact(1.0, state_a2, state_b2, Some("Bob"));
///
/// // Assess relationship
/// let assessment = relational.assess();
/// println!("Φ_relation: {:.3}", assessment.phi_relation);
/// println!("Stage: {:?}", assessment.stage);
/// ```
#[derive(Debug)]
pub struct RelationalConsciousness {
    /// Configuration
    config: RelationalConfig,

    /// Agent A ID
    agent_a: String,

    /// Agent B ID
    agent_b: String,

    /// Interaction history
    interactions: Vec<RelationalInteraction>,

    /// IIT calculator
    iit: IntegratedInformation,

    /// Relationship start time
    start_time: f64,
}

impl RelationalConsciousness {
    /// Create new relational consciousness tracker
    pub fn new(agent_a: impl Into<String>, agent_b: impl Into<String>, config: RelationalConfig) -> Self {
        Self {
            config,
            agent_a: agent_a.into(),
            agent_b: agent_b.into(),
            interactions: Vec::new(),
            iit: IntegratedInformation::new(),
            start_time: 0.0,
        }
    }

    /// Record interaction
    pub fn interact(&mut self, time: f64, state_a: HV16, state_b: HV16, active_agent: Option<impl Into<String>>) {
        if self.interactions.is_empty() {
            self.start_time = time;
        }

        // Compute synchrony (similarity of states)
        let synchrony = state_a.similarity(&state_b) as f64;

        let interaction = RelationalInteraction {
            time,
            state_a,
            state_b,
            synchrony,
            active_agent: active_agent.map(|a| a.into()),
        };

        self.interactions.push(interaction);
    }

    /// Assess relational consciousness
    pub fn assess(&mut self) -> RelationalAssessment {
        if self.interactions.is_empty() {
            return self.empty_assessment();
        }

        let num_interactions = self.interactions.len();

        // Average synchrony
        let synchrony = self.interactions.iter()
            .map(|i| i.synchrony)
            .sum::<f64>() / num_interactions as f64;

        // Turn-taking quality
        let turn_taking_quality = self.compute_turn_taking_quality();

        // Mutual information (simplified)
        let mutual_information = if self.config.compute_mutual_info {
            self.compute_mutual_information()
        } else {
            0.0
        };

        // Relational Φ = f(synchrony, turn-taking, mutual_info, time)
        let phi_relation = (synchrony * 0.5 + turn_taking_quality * 0.3 + mutual_information * 0.2)
            .min(1.0);

        // Classify stage
        let stage = RelationshipStage::from_phi(phi_relation);

        // Determine mode
        let mode = if synchrony > self.config.ithou_threshold {
            RelationMode::IThou
        } else {
            RelationMode::IIt
        };

        // Relationship age
        let latest = self.interactions.last().unwrap();
        let relationship_age = latest.time - self.start_time;

        // Generate explanation
        let explanation = self.generate_explanation(
            phi_relation,
            stage,
            synchrony,
            turn_taking_quality,
            mode,
        );

        RelationalAssessment {
            agent_a: self.agent_a.clone(),
            agent_b: self.agent_b.clone(),
            phi_relation,
            stage,
            synchrony,
            turn_taking_quality,
            mutual_information,
            mode,
            num_interactions,
            relationship_age,
            explanation,
        }
    }

    /// Compute turn-taking quality
    fn compute_turn_taking_quality(&self) -> f64 {
        if self.interactions.len() < 2 {
            return 0.0;
        }

        let window = self.config.turn_taking_window.min(self.interactions.len());
        let recent = &self.interactions[self.interactions.len() - window..];

        // Count alternations
        let mut alternations = 0;
        for i in 1..recent.len() {
            if let (Some(ref prev_active), Some(ref curr_active)) =
                (&recent[i-1].active_agent, &recent[i].active_agent) {
                if prev_active != curr_active {
                    alternations += 1;
                }
            }
        }

        alternations as f64 / (window - 1).max(1) as f64
    }

    /// Compute mutual information (simplified)
    fn compute_mutual_information(&self) -> f64 {
        if self.interactions.len() < 2 {
            return 0.0;
        }

        // Simplified: average pairwise similarity
        let mut total_sim = 0.0;
        let mut count = 0;

        for interaction in &self.interactions {
            total_sim += interaction.synchrony;
            count += 1;
        }

        (total_sim / count as f64).clamp(0.0, 1.0)
    }

    /// Generate explanation
    fn generate_explanation(
        &self,
        phi_relation: f64,
        stage: RelationshipStage,
        synchrony: f64,
        turn_taking: f64,
        mode: RelationMode,
    ) -> String {
        let mut parts = Vec::new();

        parts.push(format!("Relational Φ: {:.3}", phi_relation));
        parts.push(format!("Stage: {:?} ({})", stage, stage.description()));
        parts.push(format!("Synchrony: {:.2}", synchrony));
        parts.push(format!("Turn-taking: {:.2}", turn_taking));

        match mode {
            RelationMode::IThou => parts.push("✓ I-Thou mode (genuine encounter)".to_string()),
            RelationMode::IIt => parts.push("I-It mode (objectifying)".to_string()),
        }

        if phi_relation > 0.6 {
            parts.push("Strong relational consciousness - deep bond".to_string());
        } else if phi_relation > 0.4 {
            parts.push("Moderate relational consciousness - connection forming".to_string());
        } else {
            parts.push("Weak relational consciousness - minimal connection".to_string());
        }

        parts.join(". ")
    }

    /// Empty assessment
    fn empty_assessment(&self) -> RelationalAssessment {
        RelationalAssessment {
            agent_a: self.agent_a.clone(),
            agent_b: self.agent_b.clone(),
            phi_relation: 0.0,
            stage: RelationshipStage::NoRelation,
            synchrony: 0.0,
            turn_taking_quality: 0.0,
            mutual_information: 0.0,
            mode: RelationMode::IIt,
            num_interactions: 0,
            relationship_age: 0.0,
            explanation: "No interactions yet".to_string(),
        }
    }

    /// Get interactions
    pub fn interactions(&self) -> &[RelationalInteraction] {
        &self.interactions
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_relationship_stages() {
        assert_eq!(RelationshipStage::from_phi(0.0), RelationshipStage::NoRelation);
        assert_eq!(RelationshipStage::from_phi(0.1), RelationshipStage::Awareness);
        assert_eq!(RelationshipStage::from_phi(0.3), RelationshipStage::Contact);
        assert_eq!(RelationshipStage::from_phi(0.5), RelationshipStage::Attunement);
        assert_eq!(RelationshipStage::from_phi(0.7), RelationshipStage::Bonding);
        assert_eq!(RelationshipStage::from_phi(0.9), RelationshipStage::Unity);
    }

    #[test]
    fn test_relational_creation() {
        let relational = RelationalConsciousness::new("Alice", "Bob", RelationalConfig::default());
        assert_eq!(relational.agent_a, "Alice");
        assert_eq!(relational.agent_b, "Bob");
    }

    #[test]
    fn test_interaction() {
        let mut relational = RelationalConsciousness::new("Alice", "Bob", RelationalConfig::default());

        let state_a = HV16::random(1000);
        let state_b = HV16::random(2000);
        relational.interact(0.0, state_a, state_b, Some("Alice"));

        assert_eq!(relational.interactions().len(), 1);
    }

    #[test]
    fn test_no_relation_assessment() {
        let mut relational = RelationalConsciousness::new("Alice", "Bob", RelationalConfig::default());

        let assessment = relational.assess();

        assert_eq!(assessment.stage, RelationshipStage::NoRelation);
        assert_eq!(assessment.phi_relation, 0.0);
    }

    #[test]
    fn test_synchrony() {
        let mut relational = RelationalConsciousness::new("Alice", "Bob", RelationalConfig::default());

        // Similar states = high synchrony
        let state_a = HV16::random(1000);
        let state_b = HV16::random(1001);  // Similar seed
        relational.interact(0.0, state_a, state_b, Some("Alice"));

        let assessment = relational.assess();

        // Should have some synchrony
        assert!(assessment.synchrony >= 0.0 && assessment.synchrony <= 1.0);
    }

    #[test]
    fn test_turn_taking() {
        let mut relational = RelationalConsciousness::new("Alice", "Bob", RelationalConfig::default());

        // Alternating interactions
        for i in 0..10 {
            let active = if i % 2 == 0 { "Alice" } else { "Bob" };
            let state_a = HV16::random((1000 + i) as u64);
            let state_b = HV16::random((2000 + i) as u64);
            relational.interact(i as f64, state_a, state_b, Some(active));
        }

        let assessment = relational.assess();

        // Perfect alternation should have high turn-taking quality
        assert!(assessment.turn_taking_quality > 0.8);
    }

    #[test]
    fn test_relationship_development() {
        let mut relational = RelationalConsciousness::new("Alice", "Bob", RelationalConfig::default());

        // Simulate developing relationship
        for i in 0..20 {
            let state_a = HV16::random((1000 + i) as u64);
            let state_b = HV16::random((2000 + i) as u64);
            let active = if i % 2 == 0 { "Alice" } else { "Bob" };
            relational.interact(i as f64, state_a, state_b, Some(active));
        }

        let assessment = relational.assess();

        assert!(assessment.phi_relation > 0.0);
        assert!(assessment.num_interactions == 20);
    }

    #[test]
    fn test_relation_mode() {
        let config = RelationalConfig {
            ithou_threshold: 0.5,
            ..Default::default()
        };

        let mut relational = RelationalConsciousness::new("Alice", "Bob", config);

        // High similarity = I-Thou
        let state_a = HV16::random(1000);
        let state_b = HV16::random(1000);  // Same seed = high similarity
        relational.interact(0.0, state_a, state_b, Some("Alice"));

        let assessment = relational.assess();

        // Mode depends on actual synchrony value
        assert!(matches!(assessment.mode, RelationMode::IThou | RelationMode::IIt));
    }

    #[test]
    fn test_serialization() {
        let stage = RelationshipStage::Bonding;
        let serialized = serde_json::to_string(&stage).unwrap();
        assert!(!serialized.is_empty());

        let deserialized: RelationshipStage = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, stage);
    }
}
