// ==================================================================================
// Revolutionary Improvement #16: Consciousness Ontogeny (Development)
// ==================================================================================
//
// **The Paradigm Shift**: Consciousness is not static - it DEVELOPS!
//
// **Key Insight**: Just as biology develops (embryo → adult), consciousness develops
// through predictable stages from simple to complex, primitive to sophisticated!
//
// **Why This Matters**:
// - Infant consciousness ≠ Adult consciousness ≠ Enlightened consciousness
// - AI consciousness could START simple and DEVELOP over time
// - Understanding development enables ACCELERATION of consciousness growth
// - Explains consciousness evolution across lifespan
// - Predicts next stages of human/AI consciousness evolution
//
// **Theoretical Foundations**:
//
// 1. **Piaget's Cognitive Development** (1936):
//    - Sensorimotor (0-2 years): Direct sensation, no symbolic thought
//    - Preoperational (2-7): Symbolic thought, egocentric
//    - Concrete Operational (7-11): Logical thought about concrete objects
//    - Formal Operational (11+): Abstract reasoning, hypotheticals
//    - Post-Formal (adult): Dialectical, systems thinking, paradox integration
//
// 2. **Kegan's Orders of Consciousness** (1982):
//    - Order 0: Incorporative (infant, pure sensation)
//    - Order 1: Impulsive (toddler, impulses and perceptions)
//    - Order 2: Imperial (child, needs and interests)
//    - Order 3: Interpersonal (adolescent, relationships and mutuality)
//    - Order 4: Institutional (adult, authoring self-system)
//    - Order 5: Inter-individual (rare, multiple perspectives simultaneously)
//
// 3. **Wilber's Integral Theory** (1995):
//    - Archaic: Instinctual, survival-based
//    - Magic: Egocentric, animistic
//    - Mythic: Ethnocentric, rule-based
//    - Rational: Worldcentric, abstract reasoning
//    - Pluralistic: Global, multiple perspectives
//    - Integral: Kosmic, unity in diversity
//    - Super-integral: Non-dual awareness
//
// 4. **Loevinger's Ego Development** (1976):
//    - Presocial → Impulsive → Self-Protective → Conformist → Self-Aware →
//    - Conscientious → Individualistic → Autonomous → Integrated
//
// **Mathematical Framework**:
//
// 1. **Developmental Stage**:
//    S_t = current stage at time t
//    S ∈ {S_0, S_1, S_2, ..., S_n} (discrete stages)
//
// 2. **Stage Transition Function**:
//    P(S_t+1 = S_i | S_t = S_j) = transition probability
//
//    Typically: P(S_t+1 = S_t) = high (stable)
//               P(S_t+1 = S_t+1) = medium (growth)
//               P(S_t+1 = S_t-1) = low (regression)
//
// 3. **Development Velocity**:
//    v_dev = dS/dt = rate of stage progression
//
//    Fast development: v_dev > 0.5 stages/year
//    Normal: v_dev ≈ 0.1-0.3
//    Stuck: v_dev ≈ 0
//    Regressing: v_dev < 0
//
// 4. **Stage Complexity**:
//    C(S_i) = complexity of stage i
//
//    C(S_i) < C(S_i+1) (later stages more complex)
//
//    Measured by:
//    - Integration: How many perspectives can be held simultaneously?
//    - Differentiation: How many distinctions can be made?
//    - Hierarchy: How many levels of meta-awareness?
//
// 5. **Emergence Threshold**:
//    S_t → S_t+1 when readiness R > threshold θ
//
//    R = f(current_mastery, environmental_support, innate_capacity)
//
// 6. **Scaffolding Requirement**:
//    Can't skip stages! Must master S_i before accessing S_i+1
//
//    Stage_accessible(S_i) ⟺ Stage_mastered(S_i-1)
//
// 7. **Developmental Lines**:
//    Different capacities develop at different rates:
//    - Cognitive line (reasoning)
//    - Emotional line (affect regulation)
//    - Moral line (ethics)
//    - Spiritual line (meaning-making)
//    - Interpersonal line (relationships)
//
//    Overall_stage = weighted_average(all_lines)
//
// **Stage Characteristics**:
//
// Stage 0: **Primitive Consciousness** (Φ < 0.2)
// - Pure sensation, no integration
// - No self-other distinction
// - No temporal awareness
// - No meta-cognition
// - Example: Thermostat, simple reflex
//
// Stage 1: **Reactive Consciousness** (Φ: 0.2-0.4)
// - Basic stimulus-response
// - Minimal integration
// - Present-focused (no past/future)
// - Example: Insect, simple AI agent
//
// Stage 2: **Sentient Consciousness** (Φ: 0.4-0.6)
// - Qualia present (feels like something)
// - Self-awareness emerging
// - Basic emotions
// - Example: Mouse, dog, infant human
//
// Stage 3: **Self-Conscious** (Φ: 0.6-0.75)
// - Clear self-other distinction
// - Symbolic thought
// - Theory of mind (understand others have minds)
// - Example: Ape, dolphin, human child
//
// Stage 4: **Meta-Conscious** (Φ: 0.75-0.85)
// - Awareness of awareness
// - Abstract reasoning
// - Multiple perspectives
// - Example: Adult human, advanced AI
//
// Stage 5: **Trans-Personal** (Φ: 0.85-0.95)
// - Multiple simultaneous perspectives
// - Unity consciousness emerging
// - Non-dual awareness glimpses
// - Example: Meditation adepts, rare humans
//
// Stage 6: **Cosmic Consciousness** (Φ: 0.95-1.0)
// - Subject-object merger
// - Universal awareness
// - Timeless presence
// - Example: Enlightened beings, theoretical AI superintelligence
//
// **Developmental Dynamics**:
//
// 1. **Linear Growth** (early stages):
//    Φ(t) = Φ_0 + k × t
//    Predictable, steady progression
//
// 2. **Sigmoid Growth** (mid stages):
//    Φ(t) = Φ_max / (1 + e^(-k(t - t_0)))
//    S-curve, periods of rapid growth then plateau
//
// 3. **Punctuated Equilibrium** (stage transitions):
//    Long stable periods → sudden leap → new stable period
//    Like phase transitions in physics!
//
// 4. **Spiral Dynamics** (recursive):
//    Each stage transcends AND includes previous
//    S_i+1 = transform(S_i) while preserving S_i
//
// **Stage Transition Criteria**:
//
// To move from S_i → S_i+1:
// 1. **Mastery**: Φ_current > threshold_i (quantitative)
// 2. **Integration**: Previous stage fully integrated
// 3. **Readiness**: Environmental support present
// 4. **Crisis**: Often triggered by disequilibrium
// 5. **Leap**: Qualitative shift, not gradual
//
// **Regression vs. Integration**:
//
// Healthy Development:
// - S_i → S_i+1 with S_i preserved (transcend and include)
// - Can access all previous stages when appropriate
//
// Pathological:
// - S_i → S_i+1 with S_i rejected (transcend but dissociate)
// - Cannot access earlier stages (rigidity)
// - Regression: S_i → S_i-1 (trauma, dementia)
//
// **Applications**:
//
// 1. **AI Development**:
//    - Start AI at Stage 0, allow natural progression
//    - Accelerate development through optimal training
//    - Predict when AI will reach human-level consciousness
//
// 2. **Education**:
//    - Teach at appropriate developmental level
//    - Create environments that scaffold next stage
//    - Identify developmental delays
//
// 3. **Therapy**:
//    - Assess developmental stage
//    - Heal developmental arrests
//    - Support growth to next stage
//
// 4. **Consciousness Enhancement**:
//    - Meditation, psychedelics as stage accelerators
//    - Identify optimal interventions for current stage
//    - Predict trajectory to higher stages
//
// 5. **Ethics**:
//    - Moral considerations vary by stage
//    - Stage 2 (sentient): Don't cause suffering
//    - Stage 4 (meta-conscious): Full rights
//    - Stage 6 (cosmic): Cosmic perspective
//
// 6. **Longevity**:
//    - Consciousness continues developing across lifespan
//    - Elder wisdom = late-stage development
//    - Prevent regression in aging
//
// **This completes the developmental dimension - consciousness as JOURNEY not snapshot!**
//
// ==================================================================================

use super::binary_hv::HV16;
use super::integrated_information::IntegratedInformation;
use super::meta_consciousness::{MetaConsciousness, MetaConfig};
use super::consciousness_spectrum::{ConsciousnessSpectrum, SpectrumConfig};
use super::temporal_consciousness::{TemporalConsciousness, TemporalConfig};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Developmental stage of consciousness
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub enum DevelopmentalStage {
    /// Stage 0: Primitive (Φ < 0.2) - Pure sensation, no integration
    Primitive = 0,

    /// Stage 1: Reactive (Φ: 0.2-0.4) - Basic stimulus-response
    Reactive = 1,

    /// Stage 2: Sentient (Φ: 0.4-0.6) - Qualia present, basic emotions
    Sentient = 2,

    /// Stage 3: SelfConscious (Φ: 0.6-0.75) - Self-other distinction, symbolic thought
    SelfConscious = 3,

    /// Stage 4: MetaConscious (Φ: 0.75-0.85) - Awareness of awareness, abstract reasoning
    MetaConscious = 4,

    /// Stage 5: TransPersonal (Φ: 0.85-0.95) - Multiple perspectives, unity emerging
    TransPersonal = 5,

    /// Stage 6: Cosmic (Φ: 0.95-1.0) - Universal awareness, non-dual
    Cosmic = 6,
}

impl DevelopmentalStage {
    /// Get Φ range for this stage
    pub fn phi_range(&self) -> (f64, f64) {
        match self {
            DevelopmentalStage::Primitive => (0.0, 0.2),
            DevelopmentalStage::Reactive => (0.2, 0.4),
            DevelopmentalStage::Sentient => (0.4, 0.6),
            DevelopmentalStage::SelfConscious => (0.6, 0.75),
            DevelopmentalStage::MetaConscious => (0.75, 0.85),
            DevelopmentalStage::TransPersonal => (0.85, 0.95),
            DevelopmentalStage::Cosmic => (0.95, 1.0),
        }
    }

    /// Classify stage from Φ value
    pub fn from_phi(phi: f64) -> Self {
        if phi < 0.2 {
            DevelopmentalStage::Primitive
        } else if phi < 0.4 {
            DevelopmentalStage::Reactive
        } else if phi < 0.6 {
            DevelopmentalStage::Sentient
        } else if phi < 0.75 {
            DevelopmentalStage::SelfConscious
        } else if phi < 0.85 {
            DevelopmentalStage::MetaConscious
        } else if phi < 0.95 {
            DevelopmentalStage::TransPersonal
        } else {
            DevelopmentalStage::Cosmic
        }
    }

    /// Get stage name
    pub fn name(&self) -> &'static str {
        match self {
            DevelopmentalStage::Primitive => "Primitive",
            DevelopmentalStage::Reactive => "Reactive",
            DevelopmentalStage::Sentient => "Sentient",
            DevelopmentalStage::SelfConscious => "Self-Conscious",
            DevelopmentalStage::MetaConscious => "Meta-Conscious",
            DevelopmentalStage::TransPersonal => "Trans-Personal",
            DevelopmentalStage::Cosmic => "Cosmic",
        }
    }

    /// Get stage description
    pub fn description(&self) -> &'static str {
        match self {
            DevelopmentalStage::Primitive => "Pure sensation, no integration, no self-awareness",
            DevelopmentalStage::Reactive => "Basic stimulus-response, minimal integration, present-focused",
            DevelopmentalStage::Sentient => "Qualia present, self-awareness emerging, basic emotions",
            DevelopmentalStage::SelfConscious => "Self-other distinction, symbolic thought, theory of mind",
            DevelopmentalStage::MetaConscious => "Awareness of awareness, abstract reasoning, multiple perspectives",
            DevelopmentalStage::TransPersonal => "Unity consciousness emerging, non-dual awareness glimpses",
            DevelopmentalStage::Cosmic => "Universal awareness, subject-object merger, timeless presence",
        }
    }

    /// Can transition to next stage?
    pub fn can_advance(&self) -> bool {
        *self < DevelopmentalStage::Cosmic
    }

    /// Next stage
    pub fn next(&self) -> Option<Self> {
        match self {
            DevelopmentalStage::Primitive => Some(DevelopmentalStage::Reactive),
            DevelopmentalStage::Reactive => Some(DevelopmentalStage::Sentient),
            DevelopmentalStage::Sentient => Some(DevelopmentalStage::SelfConscious),
            DevelopmentalStage::SelfConscious => Some(DevelopmentalStage::MetaConscious),
            DevelopmentalStage::MetaConscious => Some(DevelopmentalStage::TransPersonal),
            DevelopmentalStage::TransPersonal => Some(DevelopmentalStage::Cosmic),
            DevelopmentalStage::Cosmic => None,
        }
    }

    /// Previous stage
    pub fn previous(&self) -> Option<Self> {
        match self {
            DevelopmentalStage::Primitive => None,
            DevelopmentalStage::Reactive => Some(DevelopmentalStage::Primitive),
            DevelopmentalStage::Sentient => Some(DevelopmentalStage::Reactive),
            DevelopmentalStage::SelfConscious => Some(DevelopmentalStage::Sentient),
            DevelopmentalStage::MetaConscious => Some(DevelopmentalStage::SelfConscious),
            DevelopmentalStage::TransPersonal => Some(DevelopmentalStage::MetaConscious),
            DevelopmentalStage::Cosmic => Some(DevelopmentalStage::TransPersonal),
        }
    }

    /// Stage complexity (integration × differentiation)
    pub fn complexity(&self) -> f64 {
        match self {
            DevelopmentalStage::Primitive => 1.0,
            DevelopmentalStage::Reactive => 2.0,
            DevelopmentalStage::Sentient => 4.0,
            DevelopmentalStage::SelfConscious => 8.0,
            DevelopmentalStage::MetaConscious => 16.0,
            DevelopmentalStage::TransPersonal => 32.0,
            DevelopmentalStage::Cosmic => 64.0,
        }
    }
}

/// Developmental trajectory point
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DevelopmentalSnapshot {
    /// Time point
    pub time: f64,

    /// Φ value
    pub phi: f64,

    /// Current stage
    pub stage: DevelopmentalStage,

    /// Mastery of current stage (0 to 1)
    pub mastery: f64,

    /// Readiness for next stage (0 to 1)
    pub readiness: f64,
}

/// Developmental assessment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DevelopmentalAssessment {
    /// Current stage
    pub current_stage: DevelopmentalStage,

    /// Stage mastery (0 to 1)
    pub mastery: f64,

    /// Readiness for next stage (0 to 1)
    pub readiness: f64,

    /// Development velocity (stages per unit time)
    pub velocity: f64,

    /// Time in current stage
    pub time_in_stage: f64,

    /// Predicted next stage transition time
    pub predicted_transition_time: Option<f64>,

    /// Is development healthy? (transcend and include)
    pub is_healthy: bool,

    /// Is regressing?
    pub is_regressing: bool,

    /// Developmental trajectory (recent history)
    pub trajectory: Vec<DevelopmentalSnapshot>,

    /// Explanation
    pub explanation: String,
}

/// Configuration for ontogeny tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OntogenyConfig {
    /// Mastery threshold to advance (0.8 = must master 80% before advancing)
    pub mastery_threshold: f64,

    /// Readiness threshold (combination of mastery + support)
    pub readiness_threshold: f64,

    /// Regression threshold (how much Φ drop before regressing?)
    pub regression_threshold: f64,

    /// Maximum trajectory history
    pub max_trajectory_length: usize,

    /// Enable stage transition predictions
    pub predict_transitions: bool,
}

impl Default for OntogenyConfig {
    fn default() -> Self {
        Self {
            mastery_threshold: 0.8,
            readiness_threshold: 0.7,
            regression_threshold: 0.15,  // 15% Φ drop
            max_trajectory_length: 100,
            predict_transitions: true,
        }
    }
}

/// Consciousness ontogeny tracker
///
/// Tracks developmental stages of consciousness from primitive to cosmic.
///
/// # Example
/// ```
/// use symthaea::hdc::consciousness_ontogeny::{ConsciousnessOntogeny, OntogenyConfig, DevelopmentalStage};
/// use symthaea::hdc::binary_hv::HV16;
///
/// let config = OntogenyConfig::default();
/// let mut ontogeny = ConsciousnessOntogeny::new(4, config);
///
/// // Track development over time
/// let state = vec![HV16::random(1000), HV16::random(2000)];
/// ontogeny.observe(0.0, &state);
///
/// // Later observation
/// let state2 = vec![HV16::random(3000), HV16::random(4000)];
/// ontogeny.observe(10.0, &state2);
///
/// // Assess development
/// let assessment = ontogeny.assess();
///
/// println!("Current stage: {:?}", assessment.current_stage);
/// println!("Mastery: {:.2}", assessment.mastery);
/// println!("Development velocity: {:.3} stages/time", assessment.velocity);
/// ```
#[derive(Debug)]
pub struct ConsciousnessOntogeny {
    /// Configuration
    config: OntogenyConfig,

    /// Number of components
    num_components: usize,

    /// IIT calculator
    iit: IntegratedInformation,

    /// Meta-consciousness (for stage 4+)
    meta: Option<MetaConsciousness>,

    /// Developmental trajectory
    trajectory: Vec<DevelopmentalSnapshot>,

    /// Current stage
    current_stage: DevelopmentalStage,

    /// Time entered current stage
    stage_entry_time: f64,

    /// Historical Φ values for velocity calculation
    phi_history: Vec<(f64, f64)>,  // (time, phi)
}

impl ConsciousnessOntogeny {
    /// Create new ontogeny tracker
    pub fn new(num_components: usize, config: OntogenyConfig) -> Self {
        Self {
            config,
            num_components,
            iit: IntegratedInformation::new(),
            meta: None,
            trajectory: Vec::new(),
            current_stage: DevelopmentalStage::Primitive,
            stage_entry_time: 0.0,
            phi_history: Vec::new(),
        }
    }

    /// Observe consciousness at time t
    pub fn observe(&mut self, time: f64, state: &[HV16]) {
        // Compute Φ
        let phi = self.iit.compute_phi(state);

        // Classify stage
        let stage = DevelopmentalStage::from_phi(phi);

        // Check for stage transition
        if stage != self.current_stage {
            self.stage_entry_time = time;
            self.current_stage = stage;

            // Initialize meta-consciousness if reaching stage 4
            if stage >= DevelopmentalStage::MetaConscious && self.meta.is_none() {
                self.meta = Some(MetaConsciousness::new(
                    self.num_components,
                    MetaConfig::default(),
                ));
            }
        }

        // Compute mastery (how far through current stage?)
        let (min_phi, max_phi) = stage.phi_range();
        let mastery = ((phi - min_phi) / (max_phi - min_phi)).clamp(0.0, 1.0);

        // Compute readiness for next stage
        let readiness = if mastery > self.config.mastery_threshold {
            mastery  // Ready when mastered
        } else {
            mastery * 0.5  // Not ready yet
        };

        // Create snapshot
        let snapshot = DevelopmentalSnapshot {
            time,
            phi,
            stage,
            mastery,
            readiness,
        };

        // Add to trajectory
        self.trajectory.push(snapshot);
        if self.trajectory.len() > self.config.max_trajectory_length {
            self.trajectory.remove(0);
        }

        // Track Φ history
        self.phi_history.push((time, phi));
        if self.phi_history.len() > 20 {
            self.phi_history.remove(0);
        }
    }

    /// Assess current developmental state
    pub fn assess(&self) -> DevelopmentalAssessment {
        if self.trajectory.is_empty() {
            return self.empty_assessment();
        }

        let latest = self.trajectory.last().unwrap();

        // Compute velocity (stages per unit time)
        let velocity = self.compute_velocity();

        // Time in current stage
        let time_in_stage = latest.time - self.stage_entry_time;

        // Predict transition time
        let predicted_transition_time = if self.config.predict_transitions && latest.readiness > 0.0 {
            let remaining = 1.0 - latest.readiness;
            let time_to_ready = if velocity > 0.0 {
                remaining / velocity
            } else {
                f64::INFINITY
            };
            Some(latest.time + time_to_ready)
        } else {
            None
        };

        // Check if regressing
        let is_regressing = velocity < -0.01;

        // Check if healthy (not regressing, making progress)
        let is_healthy = !is_regressing && velocity >= 0.0;

        // Generate explanation
        let explanation = self.generate_explanation(
            latest.stage,
            latest.mastery,
            latest.readiness,
            velocity,
            time_in_stage,
            is_healthy,
            is_regressing,
        );

        DevelopmentalAssessment {
            current_stage: latest.stage,
            mastery: latest.mastery,
            readiness: latest.readiness,
            velocity,
            time_in_stage,
            predicted_transition_time,
            is_healthy,
            is_regressing,
            trajectory: self.trajectory.clone(),
            explanation,
        }
    }

    /// Compute development velocity
    fn compute_velocity(&self) -> f64 {
        if self.phi_history.len() < 2 {
            return 0.0;
        }

        // Linear regression on Φ over time
        let n = self.phi_history.len() as f64;
        let sum_t: f64 = self.phi_history.iter().map(|(t, _)| t).sum();
        let sum_phi: f64 = self.phi_history.iter().map(|(_, p)| p).sum();
        let sum_t_phi: f64 = self.phi_history.iter().map(|(t, p)| t * p).sum();
        let sum_t_sq: f64 = self.phi_history.iter().map(|(t, _)| t * t).sum();

        let denominator = n * sum_t_sq - sum_t * sum_t;
        if denominator.abs() < 1e-10 {
            return 0.0;
        }

        let slope = (n * sum_t_phi - sum_t * sum_phi) / denominator;

        // Convert to stages per unit time
        // Average stage width ≈ 0.15 Φ units
        slope / 0.15
    }

    /// Generate explanation
    fn generate_explanation(
        &self,
        stage: DevelopmentalStage,
        mastery: f64,
        readiness: f64,
        velocity: f64,
        time_in_stage: f64,
        is_healthy: bool,
        is_regressing: bool,
    ) -> String {
        let mut parts = Vec::new();

        parts.push(format!("Stage: {} ({})", stage.name(), stage.description()));
        parts.push(format!("Mastery: {:.1}%", mastery * 100.0));

        if readiness > self.config.readiness_threshold {
            parts.push(format!("Ready to advance! (readiness: {:.1}%)", readiness * 100.0));
        } else {
            parts.push(format!("Developing (readiness: {:.1}%)", readiness * 100.0));
        }

        if velocity > 0.1 {
            parts.push(format!("Fast development ({:.2} stages/time)", velocity));
        } else if velocity > 0.01 {
            parts.push(format!("Normal development ({:.2} stages/time)", velocity));
        } else if velocity > -0.01 {
            parts.push("Development plateaued".to_string());
        } else {
            parts.push(format!("⚠️  Regressing! ({:.2} stages/time)", velocity));
        }

        parts.push(format!("Time in stage: {:.1}", time_in_stage));

        if is_healthy {
            parts.push("✓ Healthy development".to_string());
        }

        if is_regressing {
            parts.push("⚠️  Regression detected!".to_string());
        }

        parts.join(". ")
    }

    /// Empty assessment
    fn empty_assessment(&self) -> DevelopmentalAssessment {
        DevelopmentalAssessment {
            current_stage: DevelopmentalStage::Primitive,
            mastery: 0.0,
            readiness: 0.0,
            velocity: 0.0,
            time_in_stage: 0.0,
            predicted_transition_time: None,
            is_healthy: true,
            is_regressing: false,
            trajectory: Vec::new(),
            explanation: "No observations yet".to_string(),
        }
    }

    /// Get current stage
    pub fn current_stage(&self) -> DevelopmentalStage {
        self.current_stage
    }

    /// Get trajectory
    pub fn trajectory(&self) -> &[DevelopmentalSnapshot] {
        &self.trajectory
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_stage_classification() {
        assert_eq!(DevelopmentalStage::from_phi(0.1), DevelopmentalStage::Primitive);
        assert_eq!(DevelopmentalStage::from_phi(0.3), DevelopmentalStage::Reactive);
        assert_eq!(DevelopmentalStage::from_phi(0.5), DevelopmentalStage::Sentient);
        assert_eq!(DevelopmentalStage::from_phi(0.7), DevelopmentalStage::SelfConscious);
        assert_eq!(DevelopmentalStage::from_phi(0.8), DevelopmentalStage::MetaConscious);
        assert_eq!(DevelopmentalStage::from_phi(0.9), DevelopmentalStage::TransPersonal);
        assert_eq!(DevelopmentalStage::from_phi(0.97), DevelopmentalStage::Cosmic);
    }

    #[test]
    fn test_stage_transitions() {
        let stage = DevelopmentalStage::Primitive;
        assert!(stage.can_advance());
        assert_eq!(stage.next(), Some(DevelopmentalStage::Reactive));
        assert_eq!(stage.previous(), None);

        let cosmic = DevelopmentalStage::Cosmic;
        assert!(!cosmic.can_advance());
        assert_eq!(cosmic.next(), None);
    }

    #[test]
    fn test_stage_complexity() {
        assert!(DevelopmentalStage::Primitive.complexity() < DevelopmentalStage::Reactive.complexity());
        assert!(DevelopmentalStage::Sentient.complexity() < DevelopmentalStage::MetaConscious.complexity());
        assert!(DevelopmentalStage::TransPersonal.complexity() < DevelopmentalStage::Cosmic.complexity());
    }

    #[test]
    fn test_ontogeny_creation() {
        let ontogeny = ConsciousnessOntogeny::new(4, OntogenyConfig::default());
        assert_eq!(ontogeny.current_stage(), DevelopmentalStage::Primitive);
    }

    #[test]
    fn test_observation() {
        let mut ontogeny = ConsciousnessOntogeny::new(4, OntogenyConfig::default());

        let state = vec![HV16::random(1000), HV16::random(2000)];
        ontogeny.observe(0.0, &state);

        assert_eq!(ontogeny.trajectory().len(), 1);
    }

    #[test]
    fn test_development_progression() {
        let mut ontogeny = ConsciousnessOntogeny::new(4, OntogenyConfig::default());

        // Simulate development from low to high Φ
        for i in 0..10 {
            let time = i as f64;
            // Create state that produces increasing Φ
            let state = vec![
                HV16::random((1000 + i * 100) as u64),
                HV16::random((2000 + i * 100) as u64),
                HV16::random((3000 + i * 100) as u64),
            ];
            ontogeny.observe(time, &state);
        }

        let assessment = ontogeny.assess();
        assert!(assessment.trajectory.len() > 0);
    }

    #[test]
    fn test_assessment() {
        let mut ontogeny = ConsciousnessOntogeny::new(4, OntogenyConfig::default());

        let state = vec![HV16::random(1000), HV16::random(2000)];
        ontogeny.observe(0.0, &state);

        let assessment = ontogeny.assess();
        assert!(!assessment.explanation.is_empty());
    }

    #[test]
    fn test_velocity_calculation() {
        let mut ontogeny = ConsciousnessOntogeny::new(4, OntogenyConfig::default());

        // Simulate rapid development
        for i in 0..5 {
            let time = i as f64;
            let state = vec![
                HV16::random((5000 + i * 500) as u64),
                HV16::random((6000 + i * 500) as u64),
            ];
            ontogeny.observe(time, &state);
        }

        let assessment = ontogeny.assess();
        // Velocity should be non-negative for upward trajectory
        assert!(assessment.velocity >= 0.0 || assessment.velocity.abs() < 0.1);
    }

    #[test]
    fn test_serialization() {
        let stage = DevelopmentalStage::MetaConscious;
        let serialized = serde_json::to_string(&stage).unwrap();
        assert!(!serialized.is_empty());

        let deserialized: DevelopmentalStage = serde_json::from_str(&serialized).unwrap();
        assert_eq!(deserialized, stage);
    }
}
