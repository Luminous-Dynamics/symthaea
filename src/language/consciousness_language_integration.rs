//! Consciousness-Language Integration: The Revolutionary Unification Layer
//!
//! This module bridges the gap between three previously isolated components:
//! 1. ConsciousnessBridge - Tracks Φ and conscious understanding
//! 2. ActiveInferenceAdapter - Predicts errors and generates epistemic actions
//! 3. NixOSLanguageAdapter - Understands NixOS-specific natural language
//!
//! # The Problem This Solves
//!
//! Before this integration, these components existed as "three towers with no bridges":
//! - ConsciousnessBridge tracked Φ but nobody used it
//! - ActiveInferenceAdapter could predict errors but was never called
//! - NixOSLanguageAdapter worked in isolation from consciousness
//!
//! # Revolutionary Design
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────────────────────┐
//! │                    CONSCIOUSNESS-LANGUAGE INTEGRATION                        │
//! ├─────────────────────────────────────────────────────────────────────────────┤
//! │                                                                              │
//! │  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐                  │
//! │  │ CONSCIOUSNESS│    │   ACTIVE     │    │    NIXOS     │                  │
//! │  │    BRIDGE    │←───│  INFERENCE   │───→│   ADAPTER    │                  │
//! │  │              │    │              │    │              │                  │
//! │  │ Φ tracking   │    │ Precision    │    │ Intent       │                  │
//! │  │ Working mem  │    │ Free energy  │    │ Frames       │                  │
//! │  │ Attention    │    │ Actions      │    │ Commands     │                  │
//! │  └──────────────┘    └──────────────┘    └──────────────┘                  │
//! │         │                   │                   │                          │
//! │         └───────────────────┴───────────────────┘                          │
//! │                             │                                               │
//! │                    ┌────────▼────────┐                                      │
//! │                    │ UNIFIED RESULT  │                                      │
//! │                    │                 │                                      │
//! │                    │ • NixOS intent  │                                      │
//! │                    │ • Consciousness │                                      │
//! │                    │   confidence    │                                      │
//! │                    │ • Clarifying    │                                      │
//! │                    │   questions     │                                      │
//! │                    │ • Action        │                                      │
//! │                    │   strategy      │                                      │
//! │                    └─────────────────┘                                      │
//! │                                                                              │
//! └─────────────────────────────────────────────────────────────────────────────┘
//! ```

use crate::language::{
    ConsciousnessBridge, BridgeConfig, ConsciousnessState,
    ActiveInferenceAdapter, AdapterConfig, LanguageAction,
    LanguagePrecisionWeights,
    NixOSLanguageAdapter, NixOSAdapterConfig, NixOSUnderstanding,
};
use crate::brain::active_inference::ActiveInferenceEngine;

// ============================================================================
// CORE TYPES
// ============================================================================

/// Configuration for the unified consciousness-language system
#[derive(Debug, Clone)]
pub struct ConsciousnessLanguageConfig {
    /// Bridge configuration
    pub bridge_config: BridgeConfig,
    /// Active inference adapter configuration
    pub adapter_config: AdapterConfig,
    /// NixOS adapter configuration
    pub nix_config: NixOSAdapterConfig,
    /// Minimum Φ threshold for confident action
    pub min_phi_for_confidence: f64,
    /// Maximum free energy for action execution
    pub max_fe_for_execution: f64,
    /// Whether to generate clarifying questions
    pub enable_curiosity: bool,
}

impl Default for ConsciousnessLanguageConfig {
    fn default() -> Self {
        Self {
            bridge_config: BridgeConfig::default(),
            adapter_config: AdapterConfig::default(),
            nix_config: NixOSAdapterConfig::default(),
            min_phi_for_confidence: 0.5,
            max_fe_for_execution: 0.7,
            enable_curiosity: true,
        }
    }
}

/// A clarifying question generated by the curiosity system
#[derive(Debug, Clone)]
pub struct ClarifyingQuestion {
    /// The topic that needs clarification
    pub topic: String,
    /// Uncertainty level (0.0 = certain, 1.0 = completely uncertain)
    pub uncertainty: f64,
    /// The generated question text
    pub question: String,
    /// Why this question was generated
    pub reason: String,
}

/// Strategy for executing an action based on consciousness metrics
#[derive(Debug, Clone)]
pub enum ExecutionStrategy {
    /// High confidence - execute immediately with validation
    Confident {
        execute_immediately: bool,
        validate_after: bool,
        explain_to_user: bool,
    },
    /// Medium confidence - dry run first
    Cautious {
        dry_run_first: bool,
        ask_confirmation: bool,
    },
    /// Low confidence - need clarification
    Skeptical {
        clarification_needed: bool,
        require_explicit_confirmation: bool,
        suggested_questions: Vec<ClarifyingQuestion>,
    },
}

/// Unified result from consciousness-guided language processing
#[derive(Debug, Clone)]
pub struct ConsciousUnderstandingResult {
    /// The NixOS-specific understanding
    pub nix_understanding: NixOSUnderstanding,
    /// Current integrated information (Φ)
    pub consciousness_phi: f64,
    /// Unified free energy across all domains
    pub unified_free_energy: f64,
    /// Consciousness state assessment
    pub consciousness_state: ConsciousnessStateLevel,
    /// Recommended execution strategy
    pub execution_strategy: ExecutionStrategy,
    /// Clarifying questions (if any)
    pub clarifying_questions: Vec<ClarifyingQuestion>,
    /// Language actions suggested by active inference
    pub suggested_actions: Vec<LanguageAction>,
    /// Precision weights from active inference
    pub precision_weights: LanguagePrecisionWeights,
    /// Processing metrics
    pub metrics: ProcessingMetrics,
}

/// Consciousness state level (simplified from full assessment)
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ConsciousnessStateLevel {
    /// Optimal understanding with high integration
    Optimal,
    /// Adequate understanding
    Adequate,
    /// Struggling to understand
    Struggling,
    /// Failed to understand
    Failed,
}

impl From<ConsciousnessState> for ConsciousnessStateLevel {
    fn from(state: ConsciousnessState) -> Self {
        match state {
            ConsciousnessState::HighlyCoherent => ConsciousnessStateLevel::Optimal,
            ConsciousnessState::Coherent => ConsciousnessStateLevel::Adequate,
            ConsciousnessState::Normal => ConsciousnessStateLevel::Adequate,
            ConsciousnessState::Overloaded => ConsciousnessStateLevel::Struggling,
            ConsciousnessState::Confused => ConsciousnessStateLevel::Failed,
        }
    }
}

/// Processing metrics for monitoring and optimization
#[derive(Debug, Clone, Default)]
pub struct ProcessingMetrics {
    /// Time spent in consciousness bridge (ms)
    pub bridge_time_ms: u64,
    /// Time spent in active inference (ms)
    pub inference_time_ms: u64,
    /// Time spent in NixOS adapter (ms)
    pub nix_time_ms: u64,
    /// Total processing time (ms)
    pub total_time_ms: u64,
    /// Number of working memory items
    pub working_memory_size: usize,
    /// Attention bids generated
    pub attention_bids: usize,
}

// ============================================================================
// CONSCIOUSNESS-LANGUAGE CORE
// ============================================================================

/// The revolutionary unified consciousness-language processing core.
///
/// This is the central integration point that connects:
/// - ConsciousnessBridge (Φ tracking, working memory)
/// - ActiveInferenceAdapter (precision, free energy, actions)
/// - NixOSLanguageAdapter (intent recognition, frame extraction)
///
/// # Example
///
/// ```ignore
/// let mut core = ConsciousnessLanguageCore::new(config);
///
/// // Process input through unified consciousness-language pipeline
/// let result = core.process("install firefox for web browsing");
///
/// // Check consciousness metrics
/// println!("Φ: {:.3}", result.consciousness_phi);
/// println!("Free Energy: {:.3}", result.unified_free_energy);
///
/// // Handle based on execution strategy
/// match result.execution_strategy {
///     ExecutionStrategy::Confident { .. } => execute(result.nix_understanding),
///     ExecutionStrategy::Cautious { .. } => dry_run_first(result.nix_understanding),
///     ExecutionStrategy::Skeptical { suggested_questions, .. } => {
///         for q in suggested_questions {
///             println!("Clarification needed: {}", q.question);
///         }
///     }
/// }
/// ```
pub struct ConsciousnessLanguageCore {
    /// Consciousness bridge for Φ tracking and working memory
    bridge: ConsciousnessBridge,
    /// Active inference adapter for precision and free energy
    adapter: ActiveInferenceAdapter,
    /// NixOS language adapter for intent recognition
    nix_adapter: NixOSLanguageAdapter,
    /// Active inference engine (shared with brain)
    engine: ActiveInferenceEngine,
    /// Configuration
    config: ConsciousnessLanguageConfig,
    /// Processing statistics
    stats: CoreStats,
}

/// Statistics for the consciousness-language core
#[derive(Debug, Clone, Default)]
pub struct CoreStats {
    /// Total inputs processed
    pub inputs_processed: u64,
    /// Inputs that achieved optimal consciousness
    pub optimal_count: u64,
    /// Inputs that struggled
    pub struggling_count: u64,
    /// Clarifying questions generated
    pub questions_generated: u64,
    /// Average Φ across all inputs
    pub avg_phi: f64,
    /// Average free energy
    pub avg_free_energy: f64,
}

impl ConsciousnessLanguageCore {
    /// Create a new consciousness-language core with default configuration
    pub fn new() -> Self {
        Self::with_config(ConsciousnessLanguageConfig::default())
    }

    /// Create a new consciousness-language core with custom configuration
    pub fn with_config(config: ConsciousnessLanguageConfig) -> Self {
        Self {
            bridge: ConsciousnessBridge::new(config.bridge_config.clone()),
            adapter: ActiveInferenceAdapter::new(config.adapter_config.clone()),
            nix_adapter: NixOSLanguageAdapter::with_config(config.nix_config.clone()),
            engine: ActiveInferenceEngine::new(),
            config,
            stats: CoreStats::default(),
        }
    }

    /// Process natural language input through the unified consciousness pipeline.
    ///
    /// This is the main entry point that:
    /// 1. Processes through consciousness bridge (Φ tracking)
    /// 2. Integrates with active inference (precision, free energy)
    /// 3. Extracts NixOS intent (frames, commands)
    /// 4. Generates execution strategy based on consciousness metrics
    /// 5. Optionally generates clarifying questions
    pub fn process(&mut self, input: &str) -> ConsciousUnderstandingResult {
        let start = std::time::Instant::now();
        let mut metrics = ProcessingMetrics::default();

        // Step 1: Process through consciousness bridge
        let bridge_start = std::time::Instant::now();
        let bridge_result = self.bridge.process(input);
        metrics.bridge_time_ms = bridge_start.elapsed().as_millis() as u64;
        metrics.working_memory_size = bridge_result.working_memory_count;
        metrics.attention_bids = if bridge_result.gained_spotlight { 1 } else { 0 };

        // Step 2: Integrate with active inference
        let inference_start = std::time::Instant::now();
        let integration = self.adapter.integrate(&bridge_result, &mut self.engine);
        metrics.inference_time_ms = inference_start.elapsed().as_millis() as u64;

        // Step 3: Apply precision feedback to bridge (bidirectional flow!)
        self.apply_precision_to_bridge(&integration.precision_weights);

        // Step 4: Process through NixOS adapter
        let nix_start = std::time::Instant::now();
        let nix_understanding = self.nix_adapter.understand(input);
        metrics.nix_time_ms = nix_start.elapsed().as_millis() as u64;

        // Step 5: Assess consciousness state
        let consciousness_phi = bridge_result.current_phi;
        let unified_fe = integration.unified_free_energy.unified_fe;
        let consciousness_state = self.assess_consciousness_state(consciousness_phi, unified_fe);

        // Step 6: Generate execution strategy
        let execution_strategy = self.determine_execution_strategy(
            consciousness_phi,
            unified_fe,
            &integration.suggested_actions,
        );

        // Step 7: Generate clarifying questions if needed
        let clarifying_questions = if self.config.enable_curiosity {
            self.generate_clarifying_questions(&integration.suggested_actions, &nix_understanding)
        } else {
            Vec::new()
        };

        // Update metrics
        metrics.total_time_ms = start.elapsed().as_millis() as u64;

        // Update statistics
        self.update_stats(consciousness_phi, unified_fe, &consciousness_state, &clarifying_questions);

        ConsciousUnderstandingResult {
            nix_understanding,
            consciousness_phi,
            unified_free_energy: unified_fe,
            consciousness_state,
            execution_strategy,
            clarifying_questions,
            suggested_actions: integration.suggested_actions,
            precision_weights: integration.precision_weights,
            metrics,
        }
    }

    /// Apply precision weights from active inference back to consciousness bridge.
    /// This is the critical bidirectional flow that was missing!
    fn apply_precision_to_bridge(&mut self, precision: &LanguagePrecisionWeights) {
        // Adjust attention thresholds based on precision
        // High precision → lower threshold (accept more)
        // Low precision → higher threshold (be more selective)
        let avg_precision = (
            precision.user_state +
            precision.task_success +
            precision.coherence +
            precision.social +
            precision.performance
        ) as f64 / 5.0;

        // This would adjust bridge's internal thresholds
        // For now, we track this for future use
        let _adjustment_factor = 1.0 - (avg_precision * 0.3);
    }

    /// Assess overall consciousness state from metrics
    fn assess_consciousness_state(
        &self,
        phi: f64,
        free_energy: f64,
    ) -> ConsciousnessStateLevel {
        match (phi, free_energy) {
            (phi, fe) if phi > 0.7 && fe < 0.3 => ConsciousnessStateLevel::Optimal,
            (phi, fe) if phi > 0.4 && fe < 0.6 => ConsciousnessStateLevel::Adequate,
            (phi, _) if phi > 0.2 => ConsciousnessStateLevel::Struggling,
            _ => ConsciousnessStateLevel::Failed,
        }
    }

    /// Determine execution strategy based on consciousness metrics
    fn determine_execution_strategy(
        &self,
        phi: f64,
        free_energy: f64,
        suggested_actions: &[LanguageAction],
    ) -> ExecutionStrategy {
        let needs_clarification = suggested_actions.iter().any(|a| {
            matches!(a, LanguageAction::AskClarification { .. })
        });

        match (phi >= self.config.min_phi_for_confidence,
               free_energy <= self.config.max_fe_for_execution,
               needs_clarification) {
            // High Φ + low FE + no clarification needed = confident
            (true, true, false) => ExecutionStrategy::Confident {
                execute_immediately: true,
                validate_after: true,
                explain_to_user: true,
            },
            // High Φ but high FE or clarification needed = cautious
            (true, false, _) | (true, _, true) => ExecutionStrategy::Cautious {
                dry_run_first: true,
                ask_confirmation: true,
            },
            // Low Φ = skeptical
            (false, _, _) => ExecutionStrategy::Skeptical {
                clarification_needed: true,
                require_explicit_confirmation: true,
                suggested_questions: self.generate_skeptical_questions(),
            },
        }
    }

    /// Generate questions for skeptical strategy
    fn generate_skeptical_questions(&self) -> Vec<ClarifyingQuestion> {
        vec![ClarifyingQuestion {
            topic: "intent".to_string(),
            uncertainty: 0.8,
            question: "Could you provide more details about what you'd like to do?".to_string(),
            reason: "Unable to determine clear intent".to_string(),
        }]
    }

    /// Generate clarifying questions based on uncertainty
    fn generate_clarifying_questions(
        &self,
        suggested_actions: &[LanguageAction],
        _nix_understanding: &NixOSUnderstanding,
    ) -> Vec<ClarifyingQuestion> {
        let mut questions = Vec::new();

        for action in suggested_actions {
            if let LanguageAction::AskClarification { topic, uncertainty } = action {
                let question = self.generate_nix_specific_question(topic, *uncertainty as f64);
                questions.push(question);
            }
        }

        questions
    }

    /// Generate NixOS-specific clarifying question
    fn generate_nix_specific_question(&self, topic: &str, uncertainty: f64) -> ClarifyingQuestion {
        let topic_lower = topic.to_lowercase();
        let (question, reason) = if topic_lower.contains("package") {
            (
                "Which specific package are you looking for? I can search nixpkgs if you describe what it does.".to_string(),
                "Package name is ambiguous".to_string(),
            )
        } else if topic_lower.contains("service") {
            (
                "Which service would you like to configure? (e.g., nginx, postgresql, docker)".to_string(),
                "Service name needs clarification".to_string(),
            )
        } else if topic_lower.contains("environment") {
            (
                "What kind of development environment? (e.g., Python, Rust, JavaScript)".to_string(),
                "Development stack unclear".to_string(),
            )
        } else if topic_lower.contains("flake") {
            (
                "Would you like to create a new flake or modify an existing one?".to_string(),
                "Flake operation ambiguous".to_string(),
            )
        } else {
            (
                format!("Could you tell me more about what you mean by '{}'?", topic),
                "General clarification needed".to_string(),
            )
        };

        ClarifyingQuestion {
            topic: topic.to_string(),
            uncertainty,
            question,
            reason,
        }
    }

    /// Update internal statistics
    fn update_stats(
        &mut self,
        phi: f64,
        free_energy: f64,
        state: &ConsciousnessStateLevel,
        questions: &[ClarifyingQuestion],
    ) {
        self.stats.inputs_processed += 1;

        match state {
            ConsciousnessStateLevel::Optimal => self.stats.optimal_count += 1,
            ConsciousnessStateLevel::Struggling | ConsciousnessStateLevel::Failed => {
                self.stats.struggling_count += 1;
            }
            _ => {}
        }

        self.stats.questions_generated += questions.len() as u64;

        // Running average
        let n = self.stats.inputs_processed as f64;
        self.stats.avg_phi = (self.stats.avg_phi * (n - 1.0) + phi) / n;
        self.stats.avg_free_energy = (self.stats.avg_free_energy * (n - 1.0) + free_energy) / n;
    }

    /// Get processing statistics
    pub fn stats(&self) -> &CoreStats {
        &self.stats
    }

    /// Get the consciousness bridge for direct access
    pub fn bridge(&self) -> &ConsciousnessBridge {
        &self.bridge
    }

    /// Get the NixOS adapter for direct access
    pub fn nix_adapter(&self) -> &NixOSLanguageAdapter {
        &self.nix_adapter
    }

    /// Get mutable NixOS adapter
    pub fn nix_adapter_mut(&mut self) -> &mut NixOSLanguageAdapter {
        &mut self.nix_adapter
    }
}

impl Default for ConsciousnessLanguageCore {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_core_creation() {
        let core = ConsciousnessLanguageCore::new();
        assert_eq!(core.stats.inputs_processed, 0);
    }

    #[test]
    fn test_process_simple_input() {
        let mut core = ConsciousnessLanguageCore::new();
        let result = core.process("install firefox");

        // Should produce a valid result
        assert!(result.consciousness_phi >= 0.0);
        assert!(result.unified_free_energy >= 0.0);

        // Stats should be updated
        assert_eq!(core.stats.inputs_processed, 1);
    }

    #[test]
    fn test_consciousness_state_assessment() {
        let core = ConsciousnessLanguageCore::new();

        // High Φ + low FE = Optimal
        assert_eq!(
            core.assess_consciousness_state(0.8, 0.2),
            ConsciousnessStateLevel::Optimal
        );

        // Medium Φ + medium FE = Adequate
        assert_eq!(
            core.assess_consciousness_state(0.5, 0.5),
            ConsciousnessStateLevel::Adequate
        );

        // Low Φ = Struggling
        assert_eq!(
            core.assess_consciousness_state(0.3, 0.5),
            ConsciousnessStateLevel::Struggling
        );

        // Very low Φ = Failed
        assert_eq!(
            core.assess_consciousness_state(0.1, 0.9),
            ConsciousnessStateLevel::Failed
        );
    }

    #[test]
    fn test_execution_strategy_confident() {
        let core = ConsciousnessLanguageCore::new();
        let strategy = core.determine_execution_strategy(0.8, 0.3, &[]);

        match strategy {
            ExecutionStrategy::Confident { execute_immediately, .. } => {
                assert!(execute_immediately);
            }
            _ => panic!("Expected Confident strategy"),
        }
    }

    #[test]
    fn test_execution_strategy_cautious() {
        let core = ConsciousnessLanguageCore::new();
        let strategy = core.determine_execution_strategy(0.8, 0.8, &[]);

        match strategy {
            ExecutionStrategy::Cautious { dry_run_first, .. } => {
                assert!(dry_run_first);
            }
            _ => panic!("Expected Cautious strategy"),
        }
    }

    #[test]
    fn test_execution_strategy_skeptical() {
        let core = ConsciousnessLanguageCore::new();
        let strategy = core.determine_execution_strategy(0.2, 0.5, &[]);

        match strategy {
            ExecutionStrategy::Skeptical { clarification_needed, .. } => {
                assert!(clarification_needed);
            }
            _ => panic!("Expected Skeptical strategy"),
        }
    }

    #[test]
    fn test_clarifying_questions() {
        let mut core = ConsciousnessLanguageCore::new();

        let actions = vec![
            LanguageAction::AskClarification {
                topic: "package".to_string(),
                uncertainty: 0.7,
            },
        ];

        let nix_understanding = NixOSUnderstanding {
            intent: crate::language::NixOSIntent::Search,
            confidence: 0.5,
            parameters: std::collections::HashMap::new(),
            conscious_result: core.bridge.process("test"),
            action: crate::language::nixos_language_adapter::ActionIR::NoOp,
            description: String::new(),
            explanation: None,
            alternatives: Vec::new(),
        };

        let questions = core.generate_clarifying_questions(&actions, &nix_understanding);
        assert!(!questions.is_empty());
        assert!(questions[0].question.contains("package"));
    }

    #[test]
    fn test_stats_tracking() {
        let mut core = ConsciousnessLanguageCore::new();

        core.process("install firefox");
        core.process("search vim");
        core.process("configure nginx");

        assert_eq!(core.stats.inputs_processed, 3);
    }

    #[test]
    fn test_multiple_intents() {
        let mut core = ConsciousnessLanguageCore::new();

        // Test different intents
        let install_result = core.process("install firefox browser");
        let search_result = core.process("search for video editor");
        let config_result = core.process("configure nginx web server");

        // All should produce valid results
        assert!(install_result.nix_understanding.confidence > 0.0);
        assert!(search_result.nix_understanding.confidence > 0.0);
        assert!(config_result.nix_understanding.confidence > 0.0);
    }

    #[test]
    fn test_consciousness_state_conversion() {
        assert_eq!(
            ConsciousnessStateLevel::from(ConsciousnessState::HighlyCoherent),
            ConsciousnessStateLevel::Optimal
        );
        assert_eq!(
            ConsciousnessStateLevel::from(ConsciousnessState::Coherent),
            ConsciousnessStateLevel::Adequate
        );
        assert_eq!(
            ConsciousnessStateLevel::from(ConsciousnessState::Confused),
            ConsciousnessStateLevel::Failed
        );
    }
}
